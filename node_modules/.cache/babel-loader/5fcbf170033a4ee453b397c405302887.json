{"ast":null,"code":"var $get = Symbol.for('FluidValue.get');\nvar $observers = Symbol.for('FluidValue.observers');\nexport { FluidValue, hasFluidValue, getFluidValue, getFluidObservers, callFluidObserver, callFluidObservers // Mutations\n, setFluidGetter, addFluidObserver, removeFluidObserver };\n/** Returns true if `arg` can be observed. */\n\nvar hasFluidValue = function (arg) {\n  return Boolean(arg && arg[$get]);\n};\n/**\n * Get the current value.\n * If `arg` is not observable, `arg` is returned.\n */\n\n\nvar getFluidValue = function (arg) {\n  return arg && arg[$get] ? arg[$get]() : arg;\n};\n/** Get the current observer set. Never mutate it directly! */\n\n\nvar getFluidObservers = function (target) {\n  return target[$observers] || null;\n};\n\nfunction callFluidObserver(observer, event) {\n  if (observer.eventObserved) {\n    observer.eventObserved(event);\n  } else {\n    observer(event);\n  }\n}\n\nfunction callFluidObservers(target, event) {\n  var observers = target[$observers];\n\n  if (observers) {\n    observers.forEach(function (observer) {\n      callFluidObserver(observer, event);\n    });\n  }\n}\n/**\n * Extend this class for automatic TypeScript support when passing this\n * value to `fluids`-compatible libraries.\n */\n\n\nvar FluidValue =\n/** @class */\nfunction () {\n  function FluidValue(get) {\n    if (!get && !(get = this.get)) {\n      throw Error('Unknown getter');\n    }\n\n    setFluidGetter(this, get);\n  }\n\n  return FluidValue;\n}();\n/** Define the getter called by `getFluidValue`. */\n\n\nvar setFluidGetter = function (target, get) {\n  return setHidden(target, $get, get);\n};\n\nfunction addFluidObserver(target, observer) {\n  if (target[$get]) {\n    var observers = target[$observers];\n\n    if (!observers) {\n      setHidden(target, $observers, observers = new Set());\n    }\n\n    if (!observers.has(observer)) {\n      observers.add(observer);\n\n      if (target.observerAdded) {\n        target.observerAdded(observers.size, observer);\n      }\n    }\n  }\n\n  return observer;\n}\n\nfunction removeFluidObserver(target, observer) {\n  var observers = target[$observers];\n\n  if (observers && observers.has(observer)) {\n    var count = observers.size - 1;\n\n    if (count) {\n      observers.delete(observer);\n    } else {\n      setHidden(target, $observers, null);\n    }\n\n    if (target.observerRemoved) {\n      target.observerRemoved(count, observer);\n    }\n  }\n}\n\nvar setHidden = function (target, key, value) {\n  return Object.defineProperty(target, key, {\n    value: value,\n    writable: true,\n    configurable: true\n  });\n};","map":{"version":3,"sources":["../../src/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var $get = Symbol.for('FluidValue.get');\nvar $observers = Symbol.for('FluidValue.observers');\nexport { FluidValue, hasFluidValue, getFluidValue, getFluidObservers, callFluidObserver, callFluidObservers, \n// Mutations\nsetFluidGetter, addFluidObserver, removeFluidObserver, };\n/** Returns true if `arg` can be observed. */\nvar hasFluidValue = function (arg) { return Boolean(arg && arg[$get]); };\n/**\n * Get the current value.\n * If `arg` is not observable, `arg` is returned.\n */\nvar getFluidValue = function (arg) {\n    return arg && arg[$get] ? arg[$get]() : arg;\n};\n/** Get the current observer set. Never mutate it directly! */\nvar getFluidObservers = function (target) {\n    return target[$observers] || null;\n};\nfunction callFluidObserver(observer, event) {\n    if (observer.eventObserved) {\n        observer.eventObserved(event);\n    }\n    else {\n        observer(event);\n    }\n}\nfunction callFluidObservers(target, event) {\n    var observers = target[$observers];\n    if (observers) {\n        observers.forEach(function (observer) {\n            callFluidObserver(observer, event);\n        });\n    }\n}\n/**\n * Extend this class for automatic TypeScript support when passing this\n * value to `fluids`-compatible libraries.\n */\nvar FluidValue = /** @class */ (function () {\n    function FluidValue(get) {\n        if (!get && !(get = this.get)) {\n            throw Error('Unknown getter');\n        }\n        setFluidGetter(this, get);\n    }\n    return FluidValue;\n}());\n/** Define the getter called by `getFluidValue`. */\nvar setFluidGetter = function (target, get) {\n    return setHidden(target, $get, get);\n};\nfunction addFluidObserver(target, observer) {\n    if (target[$get]) {\n        var observers = target[$observers];\n        if (!observers) {\n            setHidden(target, $observers, (observers = new Set()));\n        }\n        if (!observers.has(observer)) {\n            observers.add(observer);\n            if (target.observerAdded) {\n                target.observerAdded(observers.size, observer);\n            }\n        }\n    }\n    return observer;\n}\nfunction removeFluidObserver(target, observer) {\n    var observers = target[$observers];\n    if (observers && observers.has(observer)) {\n        var count = observers.size - 1;\n        if (count) {\n            observers.delete(observer);\n        }\n        else {\n            setHidden(target, $observers, null);\n        }\n        if (target.observerRemoved) {\n            target.observerRemoved(count, observer);\n        }\n    }\n}\nvar setHidden = function (target, key, value) {\n    return Object.defineProperty(target, key, {\n        value: value,\n        writable: true,\n        configurable: true,\n    });\n};\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}